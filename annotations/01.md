# Next 13

- Diretório app é onde ficam as páginas da aplicação
- Agora toda página precisa estar dentro de uma pasta(ex: produtos), com o arquivo page.tsx
  - `app > produtos > page.tsx`

## Arquivos

#### Layout:

- Define a estrutura que vai ser repetida entre as páginas da aplicação | semelhante aos \_app.tsx e ao \_document.tsx
- Não recarrega em quanto eu troco de tela
- Para trabalhar com diferentes layouts em partes diferentes da aplicação, eu posso criar um arquivo de layout.tsx
  dentro da pasta da página. Um exemplo é que muitas vezes as páginas de autenticação são diferentes das páginas
  internas em si, então o next vai concatenar esses layouts
- Na pasta auth por exemplo, caso eu não queira que esse nome "auth" seja usando no endereço da url, basta apenas
  colocar parenteses em volta do nome: (auth)

#### Outros tipos de arquivos

- Loading
  - página que vai ser chamado quando o next estiver fazendo um carregamento por de baixo dos panos
  - vai ser mostrada no lugar do conteúdo
  - Só precisa retornar um componente
  - Herda o layout
- Not found
  - Criar página 404
- Error
  - Erro em qualquer outro arquivo, esse arquivo será chamado
  - Mostrar alguma tela para o usuário
- Template
  - Mesmo comportamento do layout, a única diferença é que ele recarrega a cada troca de página

#### Páginas dinâmicas continuam funcionando, as diferenças são:

- nome da página e como os dados são acessados
- app > product > [slug] > page.tsx:

```tsx
interface ProductProps {
  params: {
    slug: string;
  };
}

export default function Product({ params }: ProductProps) {
  return <h1>Product: {params.slug}</h1>;
}
```

## Fetch de dados

- Posso fazer chamadas http dentro dos componentes transformando eles em assíncronos
- Chamada não será feita usando getStaticProps ou getServerSideProps

  - Todos os componentes são Server-Side First
  - Exemplo:

    - Dessa forma cobre o getStaticProps | Geração estática

      ```tsx
      import Link from "next/link";

      // Dessa forma vai revalidar toda a página, ou seja, todas as requisições dentro dela
      export const revalidate = 30; // seconds

      // Só preciso exportar como default uma função assíncrona
      export default async function Home() {
        const response = await fetch(
          "https://api.github.com/users/erik-ferreira",
          {
            next: {
              revalidate: 30, // seconds
            }, // Dessa forma vai revalidar apenas essa função
          }
        );
        const user = await response.json();

        return (
          <div>
            <h1>Home</h1>
            <pre>{JSON.stringify(user, null, 2)}</pre>
            <Link href="/app">Dashboard</Link>
          </div>
        );
      }
      ```

    - Dessa forma cobre o getServerSideProps() | Geração dinâmicas

      ```tsx
      import Link from "next/link";

      export default async function Home() {
        const response = await fetch(
          "https://api.github.com/users/erik-ferreira",
          {
            cache: "force-cache",
          }
        );
        const user = await response.json();

        return (
          <div>
            <h1>Home</h1>
            <pre>{JSON.stringify(user, null, 2)}</pre>
            <Link href="/app">Dashboard</Link>
          </div>
        );
      }
      /*
        force-cache
          - opção padrão
          - requisição sempre terá sua resposta em cache
          - Quando usuários diferentes acessarem, eles sempre vão receber a mesma versão gerada da página
        no-store
          - Não quero armazenar em cache de forma global
          - Quando usuários diferentes acessarem, a chamada sempre será diferente para cada um
      */
      ```

## Request Waterfall

- Problema da versão anterior é que quando um componente fazia uma requisição, outros componentes dentro dele que também
  faziam requisições, eram executados, isso gerava essa cascata de requisições
- O next resolveu isso da seguinte forma: De maneira automática ele vai perceber esse comportamento, e vai fazer todas
  essas requisições ao mesmo tempo, isso só não vai acontecer, quando uma requisição depender da resposta de outra
- Dica: Dentro do mesmo componente, quando tiver fazendo 2 await fetch que não dependem um do outro, utilizar o Promise.all

  ```tsx
  // Em vez disso
  export default async function Home() {
    const resp1 = await fetch("https://api.github.com/users/erik-ferreira");
    const resp2 = await fetch(
      "https://api.github.com/users/erik-ferreira/repos"
    );
  }

  // Fazer isso
  export default async function Home() {
    const [resp1, resp2] = await Promise.all(
      fetch("https://api.github.com/users/erik-ferreira"),
      fetch("https://api.github.com/users/erik-ferreira/repos")
    );
  }
  ```

<!-- 41:00 -->
